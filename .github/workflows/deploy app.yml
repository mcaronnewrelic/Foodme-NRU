name: deploy-application

on:
  workflow_run:
    workflows: ["deploy-vm"]
    types: [completed]
    branches: [main, master]
  push:
    branches: [main, master]
    paths: ['angular-app/**', 'server/**']
  workflow_dispatch:
    inputs:
      environment:
        description: Environment to deploy to
        required: true
        default: staging
        type: choice
        options: [staging, production]
      skip_infrastructure_check:
        description: Skip infrastructure validation
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  actions: write
  deployments: write
  id-token: write

env:
  AWS_REGION: us-west-2
  TF_VERSION: 1.6.0
  NODE_VERSION: 22
  SSH_CONNECTION_TIMEOUT: 30
  SSH_MAX_RETRY_ATTEMPTS: 60
  SSH_RETRY_DELAY: 5
  INSTANCE_READINESS_WAIT: 30
  ARTIFACT_RETENTION_PERIOD: 30
  APPLICATION_DEPLOY_PATH: /var/www/foodme
  DEPLOYMENT_SCRIPT_PATH: /home/ec2-user/foodme/config/deploy.sh

jobs:
  validate-infrastructure:
    name: Validate Infrastructure
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_infrastructure_check }}
    environment: ${{ github.event.inputs.environment || 'staging' }}
    outputs:
      infrastructure-ready: ${{ steps.check-infrastructure.outputs.ready }}
      instance-ip: ${{ steps.check-infrastructure.outputs.ip }}
      instance-id: ${{ steps.check-infrastructure.outputs.id }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Check infrastructure state
        id: check-infrastructure
        run: |
          cd terraform
          terraform init
          
          if ! terraform plan -detailed-exitcode > /dev/null 2>&1; then
            echo "Infrastructure not deployed or out of sync"
            echo "ready=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          INSTANCE_IP=$(terraform output -raw instance_public_ip 2>/dev/null || echo "")
          INSTANCE_ID=$(terraform output -raw instance_id 2>/dev/null || echo "")
          
          if [ -z "$INSTANCE_IP" ] || [ -z "$INSTANCE_ID" ]; then
            echo "Infrastructure outputs not available"
            echo "ready=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "ready=true" >> $GITHUB_OUTPUT
          echo "ip=$INSTANCE_IP" >> $GITHUB_OUTPUT
          echo "id=$INSTANCE_ID" >> $GITHUB_OUTPUT

      - name: Validate instance connectivity
        run: |
          INSTANCE_IP="${{ steps.check-infrastructure.outputs.ip }}"
          
          for attempt in $(seq 1 ${{ env.SSH_MAX_RETRY_ATTEMPTS }}); do
            if nc -z -w${{ env.SSH_CONNECTION_TIMEOUT }} "$INSTANCE_IP" 22; then
              echo "Instance is accessible on SSH port"
              break
            fi
            
            if [ $attempt -eq ${{ env.SSH_MAX_RETRY_ATTEMPTS }} ]; then
              echo "Instance not accessible after ${{ env.SSH_MAX_RETRY_ATTEMPTS }} attempts"
              exit 1
            fi
            
            echo "Waiting for instance (attempt $attempt/${{ env.SSH_MAX_RETRY_ATTEMPTS }})"
            sleep ${{ env.SSH_RETRY_DELAY }}
          done

  build-application:
    name: Build Application
    runs-on: ubuntu-latest
    outputs:
      artifact-name: ${{ steps.create-artifact.outputs.name }}
      build-version: ${{ steps.build-info.outputs.version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm run install:all

      - name: Build production bundle
        run: npm run build

      - name: Generate build information
        id: build-info
        run: |
          BUILD_VERSION="${{ github.sha }}-$(date +%s)"
          echo "version=$BUILD_VERSION" >> $GITHUB_OUTPUT
          echo "Build version: $BUILD_VERSION"

      - name: Validate build artifacts
        run: |
          if [ ! -d "dist/" ]; then
            echo "Build failed: dist/ directory not found"
            exit 1
          fi
          
          ARTIFACT_COUNT=$(find dist/ -type f | wc -l)
          if [ "$ARTIFACT_COUNT" -eq 0 ]; then
            echo "Build failed: No files in dist/ directory"
            exit 1
          fi
          
          echo "Build successful: $ARTIFACT_COUNT files created"

      - name: Create deployment package
        id: create-artifact
        run: |
          ARTIFACT_NAME="foodme-app-${{ steps.build-info.outputs.version }}"
          echo "name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
          
          tar -czf "$ARTIFACT_NAME.tar.gz" \
            dist/ \
            newrelic.js \
            package.json \
            --exclude="dist/**/*.map" \
            --exclude="dist/**/test/**"

      - name: Upload deployment package
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.create-artifact.outputs.name }}
          path: ${{ steps.create-artifact.outputs.name }}.tar.gz
          retention-days: ${{ env.ARTIFACT_RETENTION_PERIOD }}

  deploy-to-ec2:
    name: Deploy Application to EC2
    runs-on: ubuntu-latest
    needs: [validate-infrastructure, build-application]
    environment: ${{ github.event.inputs.environment || 'staging' }}
    if: |
      always() && 
      needs.build-application.result == 'success' && 
      (needs.validate-infrastructure.result == 'success' || inputs.skip_infrastructure_check)

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download deployment package
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build-application.outputs.artifact-name }}
          path: ./deployment

      - name: Configure SSH authentication
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          if ! ssh-keygen -l -f ~/.ssh/id_rsa >/dev/null 2>&1; then
            echo "Invalid SSH private key"
            exit 1
          fi

      - name: Deploy application bundle
        run: |
          INSTANCE_IP="${{ needs.validate-infrastructure.outputs.instance-ip }}"
          SSH_OPTIONS="-i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=${{ env.SSH_CONNECTION_TIMEOUT }}"
          
          echo "Uploading application bundle to $INSTANCE_IP"
          scp $SSH_OPTIONS "./deployment/${{ needs.build-application.outputs.artifact-name }}.tar.gz" "ec2-user@$INSTANCE_IP:/tmp/"
          
          echo "Extracting and deploying application"
          ssh $SSH_OPTIONS "ec2-user@$INSTANCE_IP" << 'DEPLOY_SCRIPT'
            set -e
            
            sudo mkdir -p ${{ env.APPLICATION_DEPLOY_PATH }}
            sudo chown ec2-user:ec2-user ${{ env.APPLICATION_DEPLOY_PATH }}
            
            cd ${{ env.APPLICATION_DEPLOY_PATH }}
            tar -xzf "/tmp/${{ needs.build-application.outputs.artifact-name }}.tar.gz"
            
            if [ -f "${{ env.DEPLOYMENT_SCRIPT_PATH }}" ]; then
              echo "Running deployment script"
              bash "${{ env.DEPLOYMENT_SCRIPT_PATH }}"
            else
              echo "No deployment script found, restarting services manually"
              sudo systemctl restart nginx || true
              sudo systemctl restart foodme-app || true
            fi
            
            echo "Deployment completed successfully"
          DEPLOY_SCRIPT

      - name: Verify deployment health
        run: |
          INSTANCE_IP="${{ needs.validate-infrastructure.outputs.instance-ip }}"
          
          for attempt in $(seq 1 10); do
            if curl -f -s "http://$INSTANCE_IP/health" >/dev/null 2>&1; then
              echo "Application health check passed"
              break
            fi
            
            if [ $attempt -eq 10 ]; then
              echo "Application health check failed after 10 attempts"
              exit 1
            fi
            
            echo "Waiting for application to start (attempt $attempt/10)"
            sleep 10
          done

      - name: Create deployment marker
        uses: newrelic/deployment-marker-action@v2.5.1
        with:
          guid: ${{ secrets.NEW_RELIC_APP_ID }}
          apiKey: ${{ secrets.NEW_RELIC_API_KEY }}
          region: US
          user: ${{ github.actor }}
          commit: ${{ github.sha }}
          changelog: ${{ github.event.head_commit.message }}
          version: ${{ needs.build-application.outputs.build-version }}

  cleanup-artifacts:
    name: Cleanup Old Artifacts
    runs-on: ubuntu-latest
    needs: [deploy-to-ec2]
    if: always()

    steps:
      - name: Remove deployment artifacts
        uses: geekyeggo/delete-artifact@v4
        with:
          name: ${{ needs.build-application.outputs.artifact-name }}
        continue-on-error: true