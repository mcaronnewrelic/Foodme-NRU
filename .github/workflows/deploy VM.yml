name: deploy-vm

on:
  push:
    branches: [main, master]
    paths: ["terraform/**"]
  pull_request:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      environment:
        description: Environment to deploy to
        required: true
        default: staging
        type: choice
        options: [staging, production]
      force_unlock:
        description: Force unlock and cleanup state
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  actions: write
  deployments: write
  id-token: write

env:
  AWS_REGION: us-west-2
  TF_VERSION: 1.6.0
  NODE_VERSION: 22
  TERRAFORM_LOCK_TIMEOUT: 10m
  TERRAFORM_RETRY_ATTEMPTS: 3
  LOCK_WAIT_INTERVAL: 30
  MAX_LOCK_WAIT_TIME: 600
  STALE_LOCK_THRESHOLD_MINUTES: 15
jobs:
  cleanup-state:
    name: Cleanup Terraform State
    runs-on: ubuntu-latest
    if: github.event.inputs.force_unlock == 'true'
    environment: ${{ github.event.inputs.environment || 'staging' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Force remove DynamoDB locks
        run: |
          LOCK_TABLE="${{ secrets.TERRAFORM_LOCK_TABLE }}"
          LOCK_KEY="${{ github.event.inputs.environment || 'staging' }}/terraform.tfstate"

          echo "Attempting to remove lock for key: $LOCK_KEY"
          aws dynamodb delete-item \
            --table-name "$LOCK_TABLE" \
            --key '{"LockID": {"S": "'"$LOCK_KEY"'"}}' || echo "No lock to remove"

      - name: Delete state file from S3
        run: |
          STATE_BUCKET="${{ secrets.TERRAFORM_STATE_BUCKET }}"
          STATE_KEY="${{ github.event.inputs.environment || 'staging' }}/terraform.tfstate"

          echo "Deleting state file: s3://$STATE_BUCKET/$STATE_KEY"
          aws s3 rm "s3://$STATE_BUCKET/$STATE_KEY" || echo "State file not found"

          echo "Deleting backup state file if it exists"
          aws s3 rm "s3://$STATE_BUCKET/$STATE_KEY.backup" || echo "Backup state file not found"

      - name: Verify cleanup
        run: |
          echo "Cleanup completed. State and locks have been removed."
          echo "You can now run a fresh deployment."

  terraform-plan:
    name: Plan Infrastructure Changes
    runs-on: ubuntu-latest
    needs: [cleanup-state]
    if: always() && !cancelled() && (needs.cleanup-state.result == 'success' || needs.cleanup-state.result == 'skipped')
    environment: ${{ github.event.inputs.environment || 'staging' }}
    # outputs:
    #   tfplan: ${{ steps.plan.outputs.tfplan }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Format Terraform files
        run: terraform fmt -recursive
        working-directory: ./terraform

      - name: Validate Terraform syntax (pre-init)
        run: |
          # Basic syntax validation without providers
          terraform fmt -check=true -diff=true ./terraform || {
            echo "Terraform files need formatting. Run 'terraform fmt -recursive' locally."
            exit 1
          }
        working-directory: ./

      - name: Check for duplicate variable declarations
        run: |
          DUPLICATE_VARS=$(grep -r "^variable " ./terraform --include="*.tf" | cut -d'"' -f2 | sort | uniq -d)
          if [ -n "$DUPLICATE_VARS" ]; then
            echo "Duplicate variable declarations found:"
            echo "$DUPLICATE_VARS"
            echo "Please remove duplicate variable declarations from your Terraform files"
            exit 1
          fi
          echo "No duplicate variables found"
        working-directory: ./terraform

      - name: Validate concurrent operations
        run: |
          LOCK_TABLE="${{ secrets.TERRAFORM_LOCK_TABLE }}"
          LOCK_KEY="${{ github.event.inputs.environment || 'staging' }}/terraform.tfstate"
          MAX_WAIT_TIME=${{ env.MAX_LOCK_WAIT_TIME }}
          WAIT_INTERVAL=${{ env.LOCK_WAIT_INTERVAL }}
          waited=0

          echo "Checking for existing locks on key: $LOCK_KEY"

          while [ $waited -lt $MAX_WAIT_TIME ]; do
            LOCK_RESPONSE=$(aws dynamodb get-item \
              --table-name "$LOCK_TABLE" \
              --key '{"LockID": {"S": "'"$LOCK_KEY"'"}}' \
              --output json 2>/dev/null || echo '{}')

            HAS_ITEM=$(echo "$LOCK_RESPONSE" | jq -r 'has("Item")')

            if [ "$HAS_ITEM" = "true" ]; then
              LOCK_INFO=$(echo "$LOCK_RESPONSE" | jq -r '.Item.Info.S // "Unknown lock info"')
              LOCK_ID=$(echo "$LOCK_RESPONSE" | jq -r '.Item.ID.S // "Unknown lock ID"')
              WHO=$(echo "$LOCK_RESPONSE" | jq -r '.Item.Who.S // "Unknown user"')
              CREATED=$(echo "$LOCK_RESPONSE" | jq -r '.Item.Created.S // "Unknown time"')
              
              echo "Active Terraform lock detected:"
              echo "  ID: $LOCK_ID"
              echo "  Who: $WHO"
              echo "  Created: $CREATED"
              echo "  Info: $LOCK_INFO"
              
              # Check if lock is stale (older than 30 minutes)
              if command -v date >/dev/null; then
                CREATED_TIMESTAMP=$(date -d "$CREATED" +%s 2>/dev/null || date -j -f "%Y-%m-%d %H:%M:%S" "$CREATED" +%s 2>/dev/null || echo "0")
                CURRENT_TIMESTAMP=$(date +%s)
                LOCK_AGE=$((CURRENT_TIMESTAMP - CREATED_TIMESTAMP))
                
                if [ $LOCK_AGE -gt 1800 ]; then  # 30 minutes
                  echo "Lock is stale (age: ${LOCK_AGE}s), attempting automatic cleanup..."
                  aws dynamodb delete-item \
                    --table-name "$LOCK_TABLE" \
                    --key '{"LockID": {"S": "'"$LOCK_KEY"'"}}'
                  echo "Stale lock removed, continuing..."
                  break
                fi
              fi
              
              if [ "${{ github.event.inputs.force_unlock }}" = "true" ]; then
                echo "Force unlock requested, removing lock..."
                aws dynamodb delete-item \
                  --table-name "$LOCK_TABLE" \
                  --key '{"LockID": {"S": "'"$LOCK_KEY"'"}}'
                echo "Lock removed successfully"
                break
              else
                echo "Waiting for lock to be released (waited: ${waited}s/${MAX_WAIT_TIME}s)"
                sleep $WAIT_INTERVAL
                waited=$((waited + WAIT_INTERVAL))
              fi
            else
              echo "No active locks found, proceeding with deployment"
              break
            fi
          done

          if [ $waited -ge $MAX_WAIT_TIME ]; then
            echo "ERROR: Timeout waiting for Terraform lock to be released!"
            echo "Lock has been active for more than ${MAX_WAIT_TIME} seconds"
            echo "To force unlock, re-run this workflow with 'force_unlock' set to true"
            echo "Or run manually: aws dynamodb delete-item --table-name '$LOCK_TABLE' --key '{\"LockID\": {\"S\": \"$LOCK_KEY\"}}'"
            exit 1
          fi

      - name: Validate Terraform files exist
        run: |
          if [ ! -d "./terraform" ]; then
            echo "ERROR: terraform directory not found"
            exit 1
          fi

          if [ ! -f "./terraform/main.tf" ]; then
            echo "ERROR: main.tf not found in terraform directory"
            exit 1
          fi

          echo "Terraform files validated"
        working-directory: ./

      - name: Check Terraform syntax before init
        run: |
          # Validate syntax without initialization
          for tf_file in $(find . -name "*.tf" -type f); do
            echo "Checking syntax of $tf_file"
            terraform fmt -check=true "$tf_file" || {
              echo "ERROR: Terraform file $tf_file has syntax errors"
              echo "Run 'terraform fmt' to fix formatting issues"
              exit 1
            }
          done
          echo "All Terraform files have valid syntax"
        working-directory: ./terraform

      - name: Initialize Terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="key=${{ github.event.inputs.environment || 'staging' }}/terraform.tfstate" \
            -backend-config="dynamodb_table=${{ secrets.TERRAFORM_LOCK_TABLE }}" \
            -backend-config="region=${{ env.AWS_REGION }}"
        working-directory: ./terraform

      - name: Validate Terraform configuration (post-init)
        run: terraform validate
        working-directory: ./terraform

      - name: Execute Terraform plan with lock timeout
        run: |
          set -e

          LOCK_TABLE="${{ secrets.TERRAFORM_LOCK_TABLE }}"
          LOCK_KEY="${{ github.event.inputs.environment || 'staging' }}/terraform.tfstate"
          MAX_ATTEMPTS=${{ env.TERRAFORM_RETRY_ATTEMPTS }}
          STALE_THRESHOLD_SECONDS=$((15 * 60))  # 15 minutes in seconds

          force_cleanup_lock() {
            echo "🔧 Force cleaning lock..."
            aws dynamodb delete-item \
              --table-name "$LOCK_TABLE" \
              --key '{"LockID": {"S": "'"$LOCK_KEY"'"}}' || echo "Lock cleanup failed"
            sleep 3
          }

          check_and_cleanup_stale_lock() {
            local attempt_number=$1
            echo "🔍 Checking for locks before attempt $attempt_number..."
            
            LOCK_RESPONSE=$(aws dynamodb get-item \
              --table-name "$LOCK_TABLE" \
              --key '{"LockID": {"S": "'"$LOCK_KEY"'"}}' \
              --output json 2>/dev/null || echo '{}')
            
            HAS_ITEM=$(echo "$LOCK_RESPONSE" | jq -r 'has("Item")')
            
            if [ "$HAS_ITEM" = "true" ]; then
              CREATED=$(echo "$LOCK_RESPONSE" | jq -r '.Item.Created.S // ""')
              WHO=$(echo "$LOCK_RESPONSE" | jq -r '.Item.Who.S // "Unknown"')
              LOCK_ID=$(echo "$LOCK_RESPONSE" | jq -r '.Item.ID.S // "Unknown"')
              OPERATION=$(echo "$LOCK_RESPONSE" | jq -r '.Item.Operation.S // "Unknown"')
              
              echo "📋 Found lock:"
              echo "  ID: $LOCK_ID"
              echo "  Who: $WHO"
              echo "  Operation: $OPERATION"
              echo "  Created: $CREATED"
              
              if [ -n "$CREATED" ] && [ "$CREATED" != "null" ]; then
                # Convert RFC3339 timestamp to epoch seconds
                CREATED_EPOCH=$(date -d "$CREATED" +%s 2>/dev/null || \
                               python3 -c "import datetime; print(int(datetime.datetime.fromisoformat('$CREATED'.replace('Z', '+00:00')).timestamp()))" 2>/dev/null || \
                               echo "0")
                
                if [ "$CREATED_EPOCH" != "0" ]; then
                  CURRENT_EPOCH=$(date +%s)
                  LOCK_AGE_SECONDS=$((CURRENT_EPOCH - CREATED_EPOCH))
                  LOCK_AGE_MINUTES=$((LOCK_AGE_SECONDS / 60))
                  
                  echo "  Age: ${LOCK_AGE_MINUTES} minutes (${LOCK_AGE_SECONDS}s)"
                  
                  if [ $LOCK_AGE_SECONDS -gt $STALE_THRESHOLD_SECONDS ]; then
                    echo "🗑️  Lock is stale (>${STALE_THRESHOLD_SECONDS}s), cleaning up..."
                    force_cleanup_lock
                    return 0
                  else
                    echo "⏰ Lock is recent, will wait or force cleanup on retry"
                    return 1
                  fi
                else
                  echo "⚠️  Cannot parse timestamp, forcing cleanup..."
                  force_cleanup_lock
                  return 0
                fi
              else
                echo "⚠️  No timestamp found, forcing cleanup..."
                force_cleanup_lock
                return 0
              fi
            else
              echo "✅ No locks found"
              return 0
            fi
          }

          for attempt in $(seq 1 $MAX_ATTEMPTS); do
            echo ""
            echo "🚀 === Terraform plan attempt $attempt/$MAX_ATTEMPTS ==="
            
            # Always check and cleanup before each attempt
            if [ $attempt -eq 1 ]; then
              check_and_cleanup_stale_lock $attempt
            else
              echo "🔧 Forcing lock cleanup before retry attempt $attempt..."
              force_cleanup_lock
            fi
            
            echo "📝 Starting terraform plan..."
            if terraform plan \
              -var="environment=${{ github.event.inputs.environment || 'staging' }}" \
              -var="app_version=${{ github.sha }}" \
              -var="db_password=${{ secrets.DB_PASSWORD }}" \
              -lock-timeout=${{ env.TERRAFORM_LOCK_TIMEOUT }} \
              -out=tfplan; then
              
              echo "✅ Terraform plan completed successfully on attempt $attempt"
              break
            else
              exit_code=$?
              echo "❌ Terraform plan failed with exit code $exit_code on attempt $attempt"
              
              # Clean up immediately after failure
              echo "🧹 Cleaning up locks after failure..."
              force_cleanup_lock
              
              if [ $attempt -eq $MAX_ATTEMPTS ]; then
                echo "💥 All $MAX_ATTEMPTS attempts failed"
                echo "🔧 Final force cleanup attempt..."
                force_cleanup_lock
                echo "💡 Manual intervention may be required:"
                echo "   - Re-run workflow with 'force_unlock: true'"
                echo "   - Or manually delete lock: aws dynamodb delete-item --table-name '$LOCK_TABLE' --key '{\"LockID\": {\"S\": \"$LOCK_KEY\"}}'"
                exit $exit_code
              fi
              
              WAIT_TIME=$((30 + (attempt * 15)))  # Progressive backoff
              echo "⏳ Waiting ${WAIT_TIME}s before attempt $((attempt + 1))..."
              sleep $WAIT_TIME
            fi
          done

          echo "🎉 Terraform plan process completed successfully"
        working-directory: ./terraform
        timeout-minutes: 35
        env:
          TF_VAR_key_name: ${{ secrets.EC2_KEY_NAME }}
          TF_VAR_allowed_cidr_blocks: ${{ secrets.ALLOWED_CIDR_BLOCKS }}

      - name: Archive execution plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ github.sha }}
          path: terraform/tfplan
          retention-days: 5

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [terraform-plan]
    environment: ${{ github.event.inputs.environment || 'staging' }}
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Download execution plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-${{ github.sha }}
          path: terraform/

      - name: Verify lock status before apply
        run: |
          LOCK_TABLE="${{ secrets.TERRAFORM_LOCK_TABLE }}"
          LOCK_KEY="${{ github.event.inputs.environment || 'staging' }}/terraform.tfstate"

          echo "Checking lock status before terraform apply..."
          LOCK_RESPONSE=$(aws dynamodb get-item \
            --table-name "$LOCK_TABLE" \
            --key '{"LockID": {"S": "'"$LOCK_KEY"'"}}' \
            --output json 2>/dev/null || echo '{}')

          HAS_ITEM=$(echo "$LOCK_RESPONSE" | jq -r 'has("Item")')

          if [ "$HAS_ITEM" = "true" ]; then
            echo "WARNING: Lock still exists, attempting cleanup..."
            aws dynamodb delete-item \
              --table-name "$LOCK_TABLE" \
              --key '{"LockID": {"S": "'"$LOCK_KEY"'"}}'
            echo "Lock removed before apply"
          else
            echo "No existing locks found"
          fi

      - name: Initialize Terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="key=${{ github.event.inputs.environment || 'staging' }}/terraform.tfstate" \
            -backend-config="dynamodb_table=${{ secrets.TERRAFORM_LOCK_TABLE }}" \
            -backend-config="region=${{ env.AWS_REGION }}"
        working-directory: ./terraform

      - name: Apply infrastructure changes
        run: |
          set -e

          LOCK_TABLE="${{ secrets.TERRAFORM_LOCK_TABLE }}"
          LOCK_KEY="${{ github.event.inputs.environment || 'staging' }}/terraform.tfstate"

          echo "🔧 Pre-apply lock cleanup..."
          aws dynamodb delete-item \
            --table-name "$LOCK_TABLE" \
            --key '{"LockID": {"S": "'"$LOCK_KEY"'"}}' || echo "No lock to clean up"

          sleep 3

          echo "🚀 Applying Terraform plan..."
          terraform apply -auto-approve -lock-timeout=${{ env.TERRAFORM_LOCK_TIMEOUT }} tfplan
          echo "✅ Terraform apply completed successfully"
        working-directory: ./terraform
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
          TF_VAR_key_name: ${{ secrets.EC2_KEY_NAME }}
          TF_VAR_allowed_cidr_blocks: ${{ secrets.ALLOWED_CIDR_BLOCKS }}

      - name: Extract instance information
        id: instance
        run: |
          INSTANCE_IP=$(terraform output -raw instance_public_ip)
          INSTANCE_ID=$(terraform output -raw instance_id)
          echo "ip=$INSTANCE_IP" >> $GITHUB_OUTPUT
          echo "id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        working-directory: ./terraform

      - name: Configure SSH authentication
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          if ! ssh-keygen -l -f ~/.ssh/id_rsa > /dev/null 2>&1; then
            echo "Invalid SSH private key"
            exit 1
          fi

      - name: Wait for instance readiness
        run: |
          for attempt in {1..60}; do
            if nc -z ${{ steps.instance.outputs.ip }} 22 2>/dev/null; then
              echo "SSH port is accessible"
              break
            fi
            echo "Waiting for SSH (attempt $attempt/60)"
            sleep 5
          done
          sleep 30

      - name: Monitor deployment status
        timeout-minutes: 15
        continue-on-error: true
        run: |
          SSH_OPTS="-i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10"

          timeout 30 ssh $SSH_OPTS ec2-user@${{ steps.instance.outputs.ip }} "cloud-init status --wait" || echo "Cloud-init monitoring failed"

          echo "Deployment logs:"
          timeout 30 ssh $SSH_OPTS ec2-user@${{ steps.instance.outputs.ip }} "sudo tail -n 50 /var/log/cloud-init-output.log" || echo "Could not retrieve logs"

      - name: Create deployment marker
        uses: newrelic/deployment-marker-action@v2.5.1
        with:
          guid: ${{ secrets.NEW_RELIC_APP_ID }}
          apiKey: ${{ secrets.NEW_RELIC_API_KEY }}
          region: US
          user: ${{ github.actor }}
          commit: ${{ github.sha }}
          changelog: ${{ github.event.head_commit.message }}
          version: ${{ github.ref_name }}
          description: "Deployed to ${{ github.event.inputs.environment || 'staging' }} by ${{ github.actor }}"

      - name: Generate deployment summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## Deployment Summary
          - **Environment**: ${{ github.event.inputs.environment || 'staging' }}
          - **Instance ID**: ${{ steps.instance.outputs.id }}
          - **Instance IP**: ${{ steps.instance.outputs.ip }}
          - **Application URL**: http://${{ steps.instance.outputs.ip }}
          - **Commit**: ${{ github.sha }}
          - **Deployed by**: ${{ github.actor }}
          EOF

  cleanup-failed-deployment:
    name: Cleanup Failed Deployment
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure]
    if: failure() && needs.deploy-infrastructure.result == 'failure'
    environment: ${{ github.event.inputs.environment || 'staging' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Clean up any remaining locks
        run: |
          LOCK_TABLE="${{ secrets.TERRAFORM_LOCK_TABLE }}"
          LOCK_KEY="${{ github.event.inputs.environment || 'staging' }}/terraform.tfstate"

          echo "Cleaning up any remaining locks..."
          aws dynamodb delete-item \
            --table-name "$LOCK_TABLE" \
            --key '{"LockID": {"S": "'"$LOCK_KEY"'"}}' || echo "No locks to clean up"
        continue-on-error: true

      - name: Initialize Terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="key=${{ github.event.inputs.environment || 'staging' }}/terraform.tfstate" \
            -backend-config="dynamodb_table=${{ secrets.TERRAFORM_LOCK_TABLE }}" \
            -backend-config="region=${{ env.AWS_REGION }}"
        working-directory: ./terraform
        continue-on-error: true

      - name: Destroy failed resources
        run: |
          set -e

          LOCK_TABLE="${{ secrets.TERRAFORM_LOCK_TABLE }}"
          LOCK_KEY="${{ github.event.inputs.environment || 'staging' }}/terraform.tfstate"

          echo "Pre-destroy lock cleanup..."
          aws dynamodb delete-item \
            --table-name "$LOCK_TABLE" \
            --key '{"LockID": {"S": "'"$LOCK_KEY"'"}}' || echo "No lock to clean up"

          sleep 5

          echo "Destroying failed resources..."
          terraform destroy -auto-approve -lock-timeout=${{ env.TERRAFORM_LOCK_TIMEOUT }} \
            -var="environment=${{ github.event.inputs.environment || 'staging' }}" \
            -var="app_version=${{ github.sha }}" \
            -var="db_password=${{ secrets.DB_PASSWORD }}"

          echo "✅ Resource destruction completed"
        working-directory: ./terraform
        env:
          TF_VAR_key_name: ${{ secrets.EC2_KEY_NAME }}
          TF_VAR_allowed_cidr_blocks: ${{ secrets.ALLOWED_CIDR_BLOCKS }}
        continue-on-error: true

      - name: Final lock cleanup
        run: |
          LOCK_TABLE="${{ secrets.TERRAFORM_LOCK_TABLE }}"
          LOCK_KEY="${{ github.event.inputs.environment || 'staging' }}/terraform.tfstate"

          echo "Final cleanup of any remaining locks..."
          aws dynamodb delete-item \
            --table-name "$LOCK_TABLE" \
            --key '{"LockID": {"S": "'"$LOCK_KEY"'"}}' || echo "No locks to clean up"
        continue-on-error: true
